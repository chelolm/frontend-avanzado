a) Realiza un esquema de los diferentes tipos de test que existen, y explica en una frase corta qué testean según la categoría. (1 punto)

Según la pirámide de test, se deben realizar tests de diferente granularidad: muchos tests pequeños y rápidos (tests unitarios), pocos tests grandes y lentos (tests e2e).
En función del tamaño de este tamaño y granularidad de test, se pueden clasificar en la siguientes categorías (de menor a mayor tamaño):
- Test unitario: es un test que comprueba el correcto funcionamiento de una unidad de código, por ejemplo, que una función o procedimiento funcione correctamente y por separado.
- Test de integración: es un test que comprueba si varias unidades de software desarrolladas de forma independiente funcionan correctamente al conectarlas entre sí, por ejemplo, la conexión del frontend a una api o a una base de datos.
- Test de contrato: es un test que comprueba si las interfaces que comunican varios servicios desarrollados por equipos separados funciona correctamente, por ejemplo, la api de interfaz entre un frontend y un backend desarrollados por dos equipos separados que sirve de contrato entre ambos.
- Test de interfaz de usuario: es un test que comprueba el correcto funcionamiento del comportamiento visual de una web, por ejemplo, realizar un test unitario de un componente visual.
- Test end to end: es un test que comprueba el correcto funcionamiento de toda la aplicación de principio a fin, por ejemplo, comprobar un customer journey completo desde que un cliente entra en la web hasta que realiza una compra online.
- Test de aceptación: es un test que comprueba que la aplicación cumple con los requisitos de negocio formulados por el cliente, por ejemplo, tests funcionales, de seguridad, escalabilidad, etc.
- Test de exploración: es un test manual que se focaliza en la creatividad del programador para detectar incidencias que no han sido detectas previamente por los tests automáticos. Su finalidad es obtener un feedback complementario para automatizar esos tests que detectan los bugs que no habían sido detectados por los tests anteriores para que no se vuelvan a repetir (test de regresión).


b) Explica qué es un “test double” y por qué son importantes a la hora de desarrollar test. (0.5 puntos)

Cuando el sistema a testear depende de un componente que no se puede usar en el test, por ejemplo, una api de terceros, es necesario reemplazar este componente por otra entidad que la sustituya y sobre la que tengamos control.
Esta entidad es el "test double" y pueden ser de tipo dummy, fake, stubs, spies o mocks en función del grado de uso en el test de la información que éstos contienen.


c) Según nuestro proyecto qué deberían testear (diagramas de nodos, igual que en el artículo) nuestros test según las categorías: (1 punto)

- Unitarios: deberían tester los getters y setters de hero.service.ts, funciones como searchHeroes, etc. comprobando que su funcionamiento es correcto.
- Integración: deberían testear que la comunicación con la api in-memory-data.service.ts funciona correctamente o bien, cuando ésta se reemplace por una api real, comprobar que funcionan correctamente al conectarlas entre sí.
- UI Test: deberían testear que al hacer click en los botones se llega a las páginas deseadas o al editar el nombre de un héreo y pulsar save, se muestran los cambios por pantalla.
- E2E Test: debería tester el flujo completo de la aplicación (customer journey) pasando por todas las posibilidades existentes.
- Aceptación: se debería comprobar el cumplimiento de los requisitos funcionales definidos en el apartado introducción así como cualquier otro requerimiento de negocio relativo a seguridad, escalabilidad, etc. que pudiese haber sido definido por el cliente previamente.